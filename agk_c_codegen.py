#!/usr/bin/env python3
"""
AGK Language C Code Generator

Generates C code from AGK AST for system programming applications.
Supports low-level system operations, memory management, and hardware access.
"""

from typing import Dict, List, Optional, Set
from agk_ast import (
    ASTNode, Program, Import, TypeNode, Parameter, FunctionDef, ExternalFunctionDef, ClassDef,
    ConstructorDef, InterfaceDef, VariableDecl, Assignment, IfStatement,
    ForStatement, WhileStatement, ReturnStatement, BreakStatement,
    ContinueStatement, TryCatchStatement, ThrowStatement, BinaryOp,
    UnaryOp, FunctionCall, AttributeAccess, ArrayAccess, Literal,
    Variable, This, ListLiteral, DictLiteral, NewExpression
)


class CCodeGenerator:
    """Generates C code from AST for system programming"""

    def __init__(self, enable_system_extensions=True):
        self.indent_level = 0
        self.output = []
        self.temp_counter = 0
        self.enable_system_extensions = enable_system_extensions
        self.includes = set()
        self.global_vars = []
        self.function_decls = []
        self.system_functions = set()

        # Add standard C includes
        self.add_include("<stdio.h>")
        self.add_include("<stdlib.h>")
        self.add_include("<string.h>")
        self.add_include("<stdbool.h>")

        # System programming includes
        if enable_system_extensions:
            self.add_include("<unistd.h>")
            self.add_include("<fcntl.h>")
            self.add_include("<sys/types.h>")
            self.add_include("<sys/stat.h>")
            self.add_include("<pthread.h>")
            self.add_include("<sys/socket.h>")
            self.add_include("<netinet/in.h>")
            self.add_include("<arpa/inet.h>")
            self.add_include("<errno.h>")

    def generate(self, program: Program) -> str:
        """Main code generation method"""
        self.output = []
        self.indent_level = 0
        self.global_vars = []
        self.function_decls = []

        # Generate header comments
        self.add_line("/*")
        self.add_line(" * Generated by AGK C Backend")
        self.add_line(" * System Programming Support Enabled")
        self.add_line(" */")
        self.add_line("")

        # Generate includes
        self.generate_includes()

        # First pass: collect function declarations and global variables
        self.collect_declarations(program)

        # Generate forward declarations
        if self.function_decls:
            self.add_line("// Forward declarations")
            for decl in self.function_decls:
                self.add_line(decl)
            self.add_line("")

        # Generate global variables
        if self.global_vars:
            self.add_line("// Global variables")
            for var in self.global_vars:
                self.add_line(var)
            self.add_line("")

        # Generate program statements
        for statement in program.statements:
            self.generate_statement(statement)

        # Generate main function if not present
        if not any(isinstance(stmt, FunctionDef) and stmt.name == "main" for stmt in program.statements):
            self.generate_main_wrapper()

        return "\n".join(self.output)

    def generate_includes(self):
        """Generate include directives"""
        for include in sorted(self.includes):
            self.add_line(f"#include {include}")
        if self.includes:
            self.add_line("")

    def add_include(self, include: str):
        """Add an include directive"""
        self.includes.add(include)

    def collect_declarations(self, program: Program):
        """First pass: collect function declarations and global variables"""
        for statement in program.statements:
            if isinstance(statement, FunctionDef):
                # Generate function declaration
                params = []
                for param in statement.parameters:
                    param_type = self.map_type_c(param.type_node) if param.type_node else "void*"
                    params.append(f"{param_type} {param.name}")

                params_str = ", ".join(params) if params else "void"
                return_type = self.map_type_c(statement.return_type) if statement.return_type else "void"
                decl = f"{return_type} {statement.name}({params_str});"
                self.function_decls.append(decl)

            elif isinstance(statement, VariableDecl) and not any(isinstance(s, FunctionDef) for s in program.statements):
                # Global variable
                var_type = self.map_type_c(statement.type_node) if statement.type_node else "int"
                init = ""
                if statement.initializer:
                    init_val = self.generate_expression(statement.initializer)
                    init = f" = {init_val}"
                self.global_vars.append(f"{var_type} {statement.name}{init};")

    def generate_main_wrapper(self):
        """Generate a main function wrapper if needed"""
        self.add_line("")
        self.add_line("int main(int argc, char* argv[]) {")
        self.indent_level += 1

        # Initialize system if needed
        if self.enable_system_extensions and self.system_functions:
            self.add_line("// Initialize system programming support")
            self.add_line("system_init();")
            self.add_line("")

        # Call user entry point if it exists
        if any(stmt.name == "program_main" for stmt in self.function_decls if "program_main(" in stmt):
            self.add_line("program_main();")
        else:
            self.add_line("printf(\"AGK System Program Started\\n\");")

        self.indent_level -= 1
        self.add_line("    return 0;")
        self.add_line("}")

    def generate_statement(self, node: ASTNode):
        """Generate code for a statement"""
        if isinstance(node, FunctionDef):
            self.generate_function_def(node)
        elif isinstance(node, ExternalFunctionDef):
            self.generate_external_function_def(node)
        elif isinstance(node, ClassDef):
            self.generate_class_def(node)
        elif isinstance(node, VariableDecl):
            self.generate_variable_decl(node)
        elif isinstance(node, Assignment):
            self.generate_assignment(node)
        elif isinstance(node, IfStatement):
            self.generate_if_statement(node)
        elif isinstance(node, ForStatement):
            self.generate_for_statement(node)
        elif isinstance(node, WhileStatement):
            self.generate_while_statement(node)
        elif isinstance(node, ReturnStatement):
            self.generate_return_statement(node)
        elif isinstance(node, BreakStatement):
            self.generate_break_statement()
        elif isinstance(node, ContinueStatement):
            self.generate_continue_statement()
        else:
            # Expression statement
            expr = self.generate_expression(node)
            if expr:
                self.add_line(f"{expr};")

    def generate_function_def(self, node: FunctionDef):
        """Generate C function definition"""
        # Generate function signature
        params = []
        for param in node.parameters:
            param_type = self.map_type_c(param.type_node) if param.type_node else "void*"
            params.append(f"{param_type} {param.name}")

        params_str = ", ".join(params) if params else "void"
        return_type = self.map_type_c(node.return_type) if node.return_type else "void"

        self.add_line(f"{return_type} {node.name}({params_str}) {{")

        # Generate function body
        self.indent_level += 1
        for statement in node.body:
            self.generate_statement(statement)
        self.indent_level -= 1

        self.add_line("}")
        self.add_line("")

    def generate_external_function_def(self, node: ExternalFunctionDef):
        """Generate external function declaration for FFI"""
        # For C backend, external functions become function pointers or direct calls
        params = []
        for param in node.parameters:
            param_type = self.map_type_c(param.type_node) if param.type_node else "void*"
            params.append(f"{param_type} {param.name}")

        params_str = ", ".join(params) if params else "void"
        return_type = self.map_type_c(node.return_type) if node.return_type else "void"

        # Add as function declaration
        self.add_line(f"// External function: {node.library_path}")
        self.add_line(f"extern {return_type} {node.name}({params_str});")
        self.add_line("")

    def generate_class_def(self, node: ClassDef):
        """Generate C struct for class definition"""
        self.add_line(f"// Class: {node.name}")
        self.add_line(f"typedef struct {node.name} {{")

        self.indent_level += 1

        # Generate fields
        for field in node.fields:
            field_type = self.map_type_c(field.type_node) if field.type_node else "void*"
            self.add_line(f"{field_type} {field.name};")

        self.indent_level -= 1
        self.add_line(f"}} {node.name}_t;")
        self.add_line("")

        # Generate methods as separate functions
        for method in node.methods:
            # Add class name prefix to method
            method.name = f"{node.name}_{method.name}"
            self.generate_function_def(method)

    def generate_variable_decl(self, node: VariableDecl):
        """Generate C variable declaration"""
        var_type = self.map_type_c(node.type_node) if node.type_node else "int"

        if node.initializer:
            init_val = self.generate_expression(node.initializer)
            self.add_line(f"{var_type} {node.name} = {init_val};")
        else:
            self.add_line(f"{var_type} {node.name};")

    def generate_assignment(self, node: Assignment):
        """Generate C assignment statement"""
        target = self.generate_expression(node.target)
        value = self.generate_expression(node.value)
        self.add_line(f"{target} {node.operator} {value};")

    def generate_if_statement(self, node: IfStatement):
        """Generate C if-else statement"""
        # Generate if
        condition = self.generate_expression(node.condition)
        self.add_line(f"if ({condition}) {{")

        self.indent_level += 1
        for statement in node.then_body:
            self.generate_statement(statement)
        self.indent_level -= 1

        self.add_line("}")

        # Generate else if branches
        for elif_condition, elif_body in node.elif_branches:
            condition = self.generate_expression(elif_condition)
            self.add_line(f"else if ({condition}) {{")

            self.indent_level += 1
            for statement in elif_body:
                self.generate_statement(statement)
            self.indent_level -= 1

            self.add_line("}")

        # Generate else
        if node.else_body:
            self.add_line("else {")

            self.indent_level += 1
            for statement in node.else_body:
                self.generate_statement(statement)
            self.indent_level -= 1

            self.add_line("}")

    def generate_for_statement(self, node: ForStatement):
        """Generate C for loop"""
        iterable = self.generate_expression(node.iterable)
        self.add_line(f"for ({node.iterator} = 0; {node.iterator} < {iterable}; {node.iterator}++) {{")

        self.indent_level += 1
        for statement in node.body:
            self.generate_statement(statement)
        self.indent_level -= 1

        self.add_line("}")

    def generate_while_statement(self, node: WhileStatement):
        """Generate C while loop"""
        condition = self.generate_expression(node.condition)
        self.add_line(f"while ({condition}) {{")

        self.indent_level += 1
        for statement in node.body:
            self.generate_statement(statement)
        self.indent_level -= 1

        self.add_line("}")

    def generate_return_statement(self, node: ReturnStatement):
        """Generate C return statement"""
        if node.value:
            value = self.generate_expression(node.value)
            self.add_line(f"return {value};")
        else:
            self.add_line("return;")

    def generate_break_statement(self):
        """Generate break statement"""
        self.add_line("break;")

    def generate_continue_statement(self):
        """Generate continue statement"""
        self.add_line("continue;")

    def generate_expression(self, node: ASTNode) -> str:
        """Generate code for an expression"""
        if isinstance(node, Literal):
            return self.generate_literal(node)
        elif isinstance(node, Variable):
            return node.name
        elif isinstance(node, BinaryOp):
            return self.generate_binary_op(node)
        elif isinstance(node, UnaryOp):
            return self.generate_unary_op(node)
        elif isinstance(node, FunctionCall):
            return self.generate_function_call(node)
        elif isinstance(node, AttributeAccess):
            return self.generate_attribute_access(node)
        elif isinstance(node, ArrayAccess):
            return self.generate_array_access(node)
        elif isinstance(node, NewExpression):
            return self.generate_new_expression(node)
        else:
            return str(node)

    def generate_literal(self, node: Literal) -> str:
        """Generate C literal value"""
        if node.type_name == "string":
            return f'"{node.value}"'
        elif node.type_name == "boolean":
            return "true" if node.value else "false"
        else:
            return str(node.value)

    def generate_binary_op(self, node: BinaryOp) -> str:
        """Generate C binary operation"""
        left = self.generate_expression(node.left)
        right = self.generate_expression(node.right)

        # Map AGK operators to C operators
        op_map = {
            '&&': '&&', '||': '||', '==': '==', '!=': '!=',
            '<': '<', '>': '>', '<=': '<=', '>=': '>=',
            '+': '+', '-': '-', '*': '*', '/': '/', '%': '%'
        }

        op = op_map.get(node.operator, node.operator)
        return f"({left} {op} {right})"

    def generate_unary_op(self, node: UnaryOp) -> str:
        """Generate C unary operation"""
        operand = self.generate_expression(node.operand)
        return f"({node.operator}{operand})"

    def generate_function_call(self, node: FunctionCall) -> str:
        """Generate C function call"""
        args = []
        for arg in node.arguments:
            args.append(self.generate_expression(arg))

        args_str = ", ".join(args)

        # Handle system programming functions
        if self.enable_system_extensions and node.function in self.get_system_functions():
            self.system_functions.add(node.function)
            return self.generate_system_call(node.function, args)

        return f"{node.function}({args_str})"

    def generate_system_call(self, func_name: str, args: List[str]) -> str:
        """Generate system programming function calls"""
        system_map = {
            'memory_allocate': f"malloc({args[0]})",
            'memory_free': f"free({args[0]})",
            'memory_copy': f"memcpy({args[0]}, {args[1]}, {args[2]})",
            'memory_set': f"memset({args[0]}, {args[1]}, {args[2]})",
            'file_open': f"open({args[0]}, {args[1]})",
            'file_close': f"close({args[0]})",
            'file_read': f"read({args[0]}, {args[1]}, {args[2]})",
            'file_write': f"write({args[0]}, {args[1]}, {args[2]})",
            'process_create': f"fork()",
            'thread_create': f"pthread_create(&{args[0]}, NULL, {args[1]}, {args[2]})",
            'thread_join': f"pthread_join({args[0]}, {args[1]})",
            'mutex_lock': f"pthread_mutex_lock(&{args[0]})",
            'mutex_unlock': f"pthread_mutex_unlock(&{args[0]})",
            'network_socket': f"socket(AF_INET, SOCK_STREAM, 0)",
            'network_bind': f"bind({args[0]}, (struct sockaddr*){args[1]}, sizeof(struct sockaddr_in))",
            'network_listen': f"listen({args[0]}, {args[1]})",
            'network_accept': f"accept({args[0]}, (struct sockaddr*){args[1]}, {args[2]})",
            'network_connect': f"connect({args[0]}, (struct sockaddr*){args[1]}, sizeof(struct sockaddr_in))"
        }

        return system_map.get(func_name, f"{func_name}({', '.join(args)})")

    def get_system_functions(self) -> Set[str]:
        """Get list of supported system functions"""
        return {
            'memory_allocate', 'memory_free', 'memory_copy', 'memory_set',
            'file_open', 'file_close', 'file_read', 'file_write', 'file_seek',
            'process_create', 'process_wait', 'process_kill',
            'thread_create', 'thread_join', 'thread_detach',
            'mutex_create', 'mutex_lock', 'mutex_unlock', 'mutex_destroy',
            'network_socket', 'network_bind', 'network_listen', 'network_accept',
            'network_connect', 'network_send', 'network_receive', 'network_close',
            'system_call', 'system_info', 'atomic_increment', 'atomic_decrement',
            'memory_barrier'
        }

    def generate_attribute_access(self, node: AttributeAccess) -> str:
        """Generate C struct member access"""
        obj = self.generate_expression(node.object)
        return f"{obj}.{node.attribute}"

    def generate_array_access(self, node: ArrayAccess) -> str:
        """Generate C array access"""
        array = self.generate_expression(node.array)
        index = self.generate_expression(node.index)
        return f"{array}[{index}]"

    def generate_new_expression(self, node: NewExpression) -> str:
        """Generate C memory allocation for objects"""
        args = []
        for arg in node.arguments:
            args.append(self.generate_expression(arg))
        args_str = ", ".join(args)

        # For C, use malloc + constructor call
        struct_name = f"{node.class_name}_t"
        return f"({struct_name}*)malloc(sizeof({struct_name}))"

    def map_type_c(self, type_node: TypeNode) -> str:
        """Map AGK types to C types"""
        if not type_node:
            return "void*"

        type_mapping = {
            'int': 'int',
            'Integer': 'int',
            'float': 'float',
            'Float': 'float',
            'double': 'double',
            'string': 'char*',
            'String': 'char*',
            'boolean': 'bool',
            'Boolean': 'bool',
            'void': 'void',
            'char': 'char',
            'byte': 'unsigned char',
            'short': 'short',
            'long': 'long',
            'size_t': 'size_t',
            'ssize_t': 'ssize_t',
            'pid_t': 'pid_t',
            'pthread_t': 'pthread_t',
            'pthread_mutex_t': 'pthread_mutex_t',
            'FILE': 'FILE*'
        }

        base_type = type_mapping.get(type_node.name, f"struct {type_node.name}_t*")

        if type_node.is_array:
            return f"{base_type}*"

        if type_node.generic_args:
            # For generic types, use void* as fallback
            return "void*"

        return base_type

    def add_line(self, line: str):
        """Add a line to the output with proper indentation"""
        indent = "    " * self.indent_level
        self.output.append(f"{indent}{line}")

    def get_temp_var(self) -> str:
        """Get a temporary variable name"""
        self.temp_counter += 1
        return f"_temp_{self.temp_counter}"